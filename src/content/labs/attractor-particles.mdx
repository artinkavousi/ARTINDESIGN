---
slug: attractor-particles
title: N-Body Attractor System
category: compute
difficulty: advanced
preview: /og/labs/attractor-particles.png
sceneComponent: '@/scenes/labs/attractor-particles/Scene'
publishedAt: '2025-01-22'
description: GPU-driven N-body simulation with gravitational/magnetic attractors using WebGPU compute shaders.
tags:
  - webgpu
  - compute
  - particles
  - physics
  - attractors
  - tsl
---

This lab demonstrates an N-body particle system where thousands of particles are attracted to multiple fixed attractor points. The simulation runs entirely on the GPU using WebGPU compute shaders, with zero CPU overhead.

## Implementation Highlights

- **GPU-Driven Physics** - All force calculations and particle updates happen in compute shaders
- **Multi-Attractor System** - Multiple attractor points with individual strengths
- **Inverse Square Law** - Realistic gravitational/magnetic force falloff
- **Velocity Damping** - Prevents infinite acceleration and creates organic motion
- **Speed Clamping** - Limits maximum particle velocity for stability
- **Dynamic Colors** - Particle colors based on distance and velocity

## How It Works

### Force Calculation
Each particle calculates forces from all attractors:
```typescript
force = Σ (strength / distance²) * direction
```

### Update Loop
1. Calculate forces from all attractors
2. Apply forces to velocity
3. Apply damping to velocity
4. Clamp maximum speed
5. Update particle position

### Compute Shader
The system uses WGSL custom functions for optimal performance:
- **Init Pass** - Spawn particles in random sphere distribution
- **Update Pass** - Calculate forces and update positions every frame

## Controls

- **Attractor Count** - Number of attractor points (1-10)
- **Attractor Strength** - Force multiplier for each attractor
- **Damping** - Velocity decay factor (0.9-0.99)
- **Max Speed** - Maximum particle velocity
- **Particle Count** - Number of simulated particles

## Visual Features

- **Distance-Based Coloring** - Particles change color based on distance from origin
- **Velocity-Based Scaling** - Faster particles appear larger
- **Additive Blending** - Creates glowing, energy-like appearance
- **Smooth Animation** - 60 FPS with 30,000+ particles

## Usage Example

```typescript
import { createAttractorSystem } from '@/lib/tsl/compute'

const system = createAttractorSystem(renderer, {
  count: 30000,
  attractorCount: 3,
  attractorStrength: 2.5,
  damping: 0.98,
  maxSpeed: 5.0,
  baseSize: 0.04,
})

await system.init()
scene.add(system.createMesh({ additive: true }))

// Animate attractors
system.setAttractorPosition(0, new Vector3(
  Math.cos(time) * 3,
  Math.sin(time) * 3,
  0
))

// Update every frame
system.update()
```

## Technical Details

- **Storage Buffers** - Uses instanced arrays for particle data
- **WGSL Functions** - Custom WGSL for force calculation
- **Hash-Based Initialization** - Deterministic random distribution
- **Double Buffering** - Separates spawn and offset positions for stability

## Performance

- 30,000 particles @ 60 FPS (RTX 3080)
- ~0.5ms compute time per frame
- Zero CPU overhead during animation
- Scales linearly with particle count

## Variations

Try experimenting with:
- **Lorenz Attractor** - Chaotic attractor system
- **Orbital Motion** - Circular/elliptical particle paths
- **Repulsors** - Negative strength attractors
- **Dynamic Attractors** - Moving attractor points
- **Multi-Species** - Different particle types with different attraction

